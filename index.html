<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>For GirlName ‚ù§Ô∏è</title>

    <style>
      body {
        margin: 0;
        background: radial-gradient(circle at top, #1a1a2e, #0f0f1a);
        font-family: "Segoe UI", sans-serif;
        overflow: hidden;
        color: white;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
      }

      canvas {
        background: rgba(0, 0, 0, 0.35);
        border-radius: 20px;
      }

      #hud {
        position: absolute;
        top: 20px;
        left: 20px;
        font-size: 18px;
        opacity: 0.9;
      }

      #messageBox {
        position: absolute;
        top: 12%;
        background: rgba(255, 255, 255, 0.96);
        padding: 18px 32px;
        border-radius: 28px;
        font-size: 22px;
        color: #ff4d6d;
        display: none;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.45);
      }

      .overlay {
        position: absolute;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        background: rgba(0, 0, 0, 0.85);
        text-align: center;
        z-index: 10;
      }

      .overlay h1 {
        font-size: 52px;
        color: #ff7eb3;
        margin-bottom: 20px;
      }

      .overlay p {
        font-size: 24px;
        max-width: 720px;
        line-height: 1.6;
      }
    </style>
  </head>

  <body>
    <canvas id="game" width="420" height="420"></canvas>

    <div id="hud"></div>
    <div id="messageBox"></div>

    <div id="finalScreen" class="overlay">
      <h1>GirlName ‚ù§Ô∏è</h1>
      <p>
        You collected every heart.<br /><br />
        Just like you collected mine.<br /><br />
        So tell me‚Ä¶<br /><br />
        <strong>Will you be my Valentine, today and forever?</strong> üíçüíñ
      </p>
    </div>

    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const hud = document.getElementById("hud");
      const messageBox = document.getElementById("messageBox");
      const finalScreen = document.getElementById("finalScreen");

      const gridSize = 20;
      const tileCount = canvas.width / gridSize;

      const TARGET_SCORE = 8; // ‚úÖ r√©duit
      const LOGIC_SPEED = 120;
      const MESSAGE_TIME = 3000;

      let snake, direction, food, score, gameEnded;

      const messages = [
        "You make my heart smile",
        "You are my safe place",
        "Every day with you is special",
        "You are my favorite person",
        "I love you, GirlName",
        "You are my forever",
      ];

      function randomFood() {
        return {
          x: Math.floor(Math.random() * tileCount),
          y: Math.floor(Math.random() * tileCount),
        };
      }

      function lerp(a, b, t) {
        return a + (b - a) * t;
      }

      function showMessage(text) {
        messageBox.textContent = text;
        messageBox.style.display = "block";
        clearTimeout(messageBox.hideTimeout);
        messageBox.hideTimeout = setTimeout(() => {
          messageBox.style.display = "none";
        }, MESSAGE_TIME);
      }

      function resetGame() {
        snake = [{ x: 10, y: 10, vx: 10, vy: 10 }];
        direction = { x: 1, y: 0 };
        food = randomFood();
        score = 0;
        gameEnded = false;
        finalScreen.style.display = "none";
        messageBox.style.display = "none";
      }

      function updateLogic() {
        if (gameEnded) return;

        const head = snake[0];
        const newHead = {
          x: head.x + direction.x,
          y: head.y + direction.y,
          vx: head.vx,
          vy: head.vy,
        };

        // üí• Collision = restart
        if (
          newHead.x < 0 ||
          newHead.y < 0 ||
          newHead.x >= tileCount ||
          newHead.y >= tileCount ||
          snake.some((s) => s.x === newHead.x && s.y === newHead.y)
        ) {
          resetGame();
          return;
        }

        snake.unshift(newHead);

        if (newHead.x === food.x && newHead.y === food.y) {
          score++;
          showMessage(messages[(score - 1) % messages.length]);
          food = randomFood();

          if (score >= TARGET_SCORE) {
            gameEnded = true;
            finalScreen.style.display = "flex";
          }
        } else {
          snake.pop();
        }
      }

      function drawHeart(x, y) {
        const px = x * gridSize;
        const py = y * gridSize;
        const s = gridSize - 4;

        ctx.fillStyle = "#ff5f9e";
        ctx.beginPath();
        ctx.moveTo(px + s / 2 + 2, py + s + 2);
        ctx.bezierCurveTo(
          px + s + 6,
          py + s / 2,
          px + s / 2 + 2,
          py,
          px + s / 2 + 2,
          py + s / 3,
        );
        ctx.bezierCurveTo(
          px,
          py,
          px - 6,
          py + s / 2,
          px + s / 2 + 2,
          py + s + 2,
        );
        ctx.fill();
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        snake.forEach((s, i) => {
          s.vx = lerp(s.vx, s.x, 0.35);
          s.vy = lerp(s.vy, s.y, 0.35);

          const px = s.vx * gridSize;
          const py = s.vy * gridSize;

          ctx.fillStyle = i === 0 ? "#ffffff" : "rgba(255,255,255,0.85)";
          ctx.beginPath();
          ctx.roundRect(px, py, gridSize - 2, gridSize - 2, 8);
          ctx.fill();
        });

        drawHeart(food.x, food.y);
        hud.textContent = `Hearts: ${score}/${TARGET_SCORE}`;
      }

      window.addEventListener("keydown", (e) => {
        if (e.key === "ArrowUp" && direction.y === 0)
          direction = { x: 0, y: -1 };
        if (e.key === "ArrowDown" && direction.y === 0)
          direction = { x: 0, y: 1 };
        if (e.key === "ArrowLeft" && direction.x === 0)
          direction = { x: -1, y: 0 };
        if (e.key === "ArrowRight" && direction.x === 0)
          direction = { x: 1, y: 0 };
      });

      resetGame();
      setInterval(updateLogic, LOGIC_SPEED);

      function render() {
        draw();
        requestAnimationFrame(render);
      }
      render();
    </script>
  </body>
</html>
